# 1 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 10 "<built-in>"




# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.c" 2
# 13 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.c"
# 1 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdlib.h" 1
# 14 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdlib.h"
# 1 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\astree_config.h" 1
# 471 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\astree_config.h"
__ASTREE_attributes((coverage_ignore, raise_at_caller, hide_directives));
# 15 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdlib.h" 2
# 1 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stddef.h" 1
# 20 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stddef.h"
typedef long int ptrdiff_t;
typedef long unsigned int size_t;


typedef int wchar_t;
# 46 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stddef.h"
typedef int errno_t;


typedef double long max_align_t;

typedef size_t rsize_t;






__ASTREE_attributes((coverage_ignore, raise_at_caller, hide_directives));
# 16 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdlib.h" 2
# 1 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\astree_restrict.h" 1
# 22 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\astree_restrict.h"
__ASTREE_attributes((coverage_ignore, raise_at_caller, hide_directives));
# 17 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdlib.h" 2





typedef struct {
    int quot;
    int rem;
} div_t;

typedef struct {
    long int quot;
    long int rem;
} ldiv_t;

typedef struct {
    long long int quot;
    long long int rem;
} lldiv_t;
# 55 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdlib.h"
double atof(const char *nptr);
int atoi(const char *nptr);
long int atol(const char *nptr);
long long int atoll(const char *nptr);
double strtod(const char * restrict nptr, char ** restrict endptr);
float strtof(const char * restrict nptr, char ** restrict endptr);
long double strtold(const char * restrict nptr, char ** restrict endptr);
long int strtol(const char * restrict nptr, char ** restrict endptr, int base);
long long int strtoll(const char * restrict nptr, char ** restrict endptr, int base);
unsigned long int strtoul(const char * restrict nptr, char ** restrict endptr, int base);
unsigned long long int strtoull(const char * restrict nptr, char ** restrict endptr, int base);
int rand(void);
void srand(unsigned int seed);
void *aligned_alloc(size_t alignment, size_t size);
void *calloc(size_t nmemb, size_t size);
void free(void *ptr);
void *malloc(size_t size);
void *realloc(void *ptr, size_t size);
_Noreturn void abort(void);
int atexit(void (*func)(void));
int at_quick_exit(void (*func)(void));
_Noreturn void exit(int status);
_Noreturn void _Exit(int status);
char *getenv(const char *name);
_Noreturn void quick_exit(int status);
int system(const char *string);
void *bsearch(const void *key, const void *base, size_t nmemb, size_t size,
int (*compar)(const void *, const void *));
void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
int abs(int j);
long int labs(long int j);
long long int llabs(long long int j);
div_t div(int numer, int denom);
ldiv_t ldiv(long int numer, long int denom);
lldiv_t lldiv(long long int numer, long long int denom);
int mblen(const char *s, size_t n);
int mbtowc(wchar_t * restrict pwc, const char * restrict s, size_t n);
int wctomb(char *s, wchar_t wchar);
size_t mbstowcs(wchar_t * restrict pwcs, const char * restrict s, size_t n);
size_t wcstombs(char * restrict s, const wchar_t * restrict pwcs, size_t n);






__ASTREE_attributes((coverage_ignore, raise_at_caller, hide_directives));
# 14 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.c" 2
# 1 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\string.h" 1
# 21 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\string.h"
void *memcpy(void * restrict s1, const void * restrict s2, size_t n);
void *memmove(void *s1, const void *s2, size_t n);
char *strcpy(char * restrict s1, const char * restrict s2);
errno_t strcpy_s(char *restrict dest, rsize_t destsz, const char *restrict src);
char *strncpy(char * restrict s1, const char * restrict s2, size_t n);
char *strcat(char * restrict s1, const char * restrict s2);
char *strncat(char * restrict s1, const char * restrict s2, size_t n);
int memcmp(const void *s1, const void *s2, size_t n);
int strcmp(const char *s1, const char *s2);
int strcoll(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t n);
size_t strxfrm(char * restrict s1, const char * restrict s2, size_t n);
void *memchr(const void *s, int c, size_t n);
char *strchr(const char *s, int c);
size_t strcspn(const char *s1, const char *s2);
char *strpbrk(const char *s1, const char *s2);
char *strrchr(const char *s, int c);
size_t strspn(const char *s1, const char *s2);
char *strstr(const char *s1, const char *s2);
char *strtok(char * restrict s1, const char * restrict s2);
void *memset(void *s, int c, size_t n);
char *strerror(int errnum);
size_t strlen(const char *s);
# 55 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\string.h"
__ASTREE_attributes((coverage_ignore, raise_at_caller, hide_directives));
# 15 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.c" 2
# 1 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdio.h" 1
# 15 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdio.h"
# 1 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdarg.h" 1
# 46 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdarg.h"
typedef union {
  int i;
  long l;
  long long ll;
  double d;
  long double dd;
  void *p;
} ASTREE_va_arg_any;

typedef ASTREE_va_arg_any *va_list;
# 69 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdarg.h"
__ASTREE_attributes((coverage_ignore, raise_at_caller, hide_directives));
# 16 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdio.h" 2






typedef struct { char dummy; } FILE;

typedef int fpos_t;
# 85 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdio.h"
extern FILE* stderr;
extern FILE* stdin;
extern FILE* stdout;

int remove(const char *filename);
int rename(const char *oldname, const char *newname);
FILE* tmpfile(void);
char* tmpnam(char* s);
int fclose(FILE* stream);
int fflush(FILE* stream);
FILE* fopen(const char* restrict filename, const char* restrict mode);
FILE* freopen(const char* restrict filename, const char* restrict mode, FILE* stream);
void setbuf(FILE* restrict stream, char* restrict buf);
int setvbuf(FILE* restrict stream, char* restrict buf, int mode, size_t size);





int fprintf(FILE* restrict stream, const char* restrict format, ...);
int fscanf(FILE* restrict stream, const char* restrict format, ...);
int printf(const char* restrict format, ...);
int scanf(const char* restrict format, ...);
int sprintf(char* restrict sm, const char* restrict format, ...);
int sscanf(const char* restrict sm, const char* restrict format, ...);
int snprintf(char* restrict s, size_t n, const char* restrict format, ...);

int vfprintf(FILE* restrict stream, const char* restrict format, va_list arg);
int vfscanf(FILE* restrict stream, const char* restrict format, va_list arg);
int vprintf(const char* restrict format, va_list arg);
int vscanf(const char* restrict format, va_list arg);
int vsnprintf(char* restrict s, size_t n, const char* restrict format, va_list arg);
int vsprintf(char* restrict s, const char* restrict format, va_list arg);
int vsscanf(const char* restrict s, const char* restrict format, va_list arg);

int fgetc(FILE* stream);
char* fgets(char* restrict s, int n, FILE* restrict stream);
int fputc(int c, FILE* stream);
int fputs(const char* restrict s, FILE* restrict stream);
int getc(FILE* stream);
int getchar(void);

char* gets(char* s);

int putc(int c, FILE* stream);
int putchar(int c);
int puts(const char* s);
int ungetc(int c, FILE* stream);
size_t fread(void* restrict ptr, size_t size, size_t nmemb, FILE* restrict stream);
size_t fwrite(const void* restrict ptr, size_t size, size_t nmemb, FILE* restrict stream);
int fgetpos(FILE* restrict stream, fpos_t* restrict pos);
int fseek(FILE* stream, long int offset, int whence);
int fsetpos(FILE* stream, const fpos_t* pos);
long int ftell(FILE* stream);
void rewind(FILE* stream);
void clearerr(FILE* stream);
int feof(FILE* stream);
int ferror(FILE* stream);
void perror(const char* s);
# 155 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdio.h"
__ASTREE_attributes((coverage_ignore, raise_at_caller, hide_directives));
# 16 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.c" 2
# 1 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/3d_party\\modp_numtoa.h" 1
# 37 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/3d_party\\modp_numtoa.h"
# 1 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdint.h" 1
# 16 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdint.h"
typedef signed char int8_t;

typedef signed short int16_t;
typedef signed int int32_t;

typedef signed long long int int64_t;


typedef unsigned char uint8_t;

typedef unsigned short uint16_t;
typedef unsigned int uint32_t;

typedef unsigned long long int uint64_t;


typedef long int intptr_t;
typedef long unsigned int uintptr_t;


typedef int8_t int_least8_t;

typedef int16_t int_least16_t;
typedef int32_t int_least32_t;

typedef int64_t int_least64_t;


typedef uint8_t uint_least8_t;

typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;

typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;

typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;

typedef int64_t int_fast64_t;


typedef uint8_t uint_fast8_t;

typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;

typedef uint64_t uint_fast64_t;


typedef long long int intmax_t;
typedef long long unsigned int uintmax_t;
# 243 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdint.h"
__ASTREE_attributes((coverage_ignore, raise_at_caller, hide_directives));
# 38 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/3d_party\\modp_numtoa.h" 2







char* modp_itoa10(int32_t value, char* buf);







char* modp_uitoa10(uint32_t value, char* buf);







char* modp_litoa10(int64_t value, char* buf);







char* modp_ulitoa10(uint64_t value, char* buf);
# 86 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/3d_party\\modp_numtoa.h"
char* modp_dtoa(double value, char* buf, int precision);
# 104 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/3d_party\\modp_numtoa.h"
char* modp_dtoa2(double value, char* buf, int precision);
# 17 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.c" 2
# 1 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/crc32.h" 1
# 18 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/crc32.h"
extern uint32_t crc32( uint32_t crc, const char *buf, uint32_t len );
# 18 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.c" 2
# 1 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3.h" 1
# 40 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3.h"
# 1 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdbool.h" 1
# 27 "C:/Program Files/AbsInt/Advanced Analyzer/c/b10672544/share/clibrary/include\\stdbool.h"
__ASTREE_attributes((coverage_ignore, raise_at_caller, hide_directives));
# 41 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3.h" 2
# 1 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_both.h" 1
# 18 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_both.h"
enum {
 EV3_KEY__NONE_ = 0,

 EV3_KEY_UP = 0x01L,
 EV3_KEY_DOWN = 0x02L,
 EV3_KEY_LEFT = 0x04L,
 EV3_KEY_RIGHT = 0x08L,
 EV3_KEY_CENTER = 0x10L,
 EV3_KEY_BACK = 0x20L,
};
# 42 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3.h" 2
# 62 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3.h"
extern char *ev3_brick_addr;




extern uint16_t ev3_brick_port;





typedef uint8_t byte;
typedef uint32_t dword;



typedef uint8_t INX_T;
typedef uint8_t FLAGS_T;
# 90 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3.h"
extern int ev3_init( void );




extern void ev3_uninit( void );
# 104 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3.h"
extern size_t ev3_write_binary( const char *fn, char *data, size_t sz );







extern size_t ev3_write( const char *fn, char *value );







extern size_t ev3_write_bool( const char *fn, _Bool value );







extern size_t ev3_write_int( const char *fn, int value );







extern size_t ev3_write_dword( const char *fn, uint32_t value );







extern size_t ev3_write_byte( const char *fn, uint8_t value );







extern size_t ev3_write_float( const char *fn, float value );

extern size_t ev3_write_char_array( const char *fn, char *value );
extern size_t ev3_write_byte_array( const char *fn, uint8_t *value, size_t sz );
# 166 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3.h"
extern size_t ev3_multi_write_binary( uint8_t *sn, uint16_t pos, const char *fn, char *data, size_t sz );

extern size_t ev3_multi_write( uint8_t *sn, uint16_t pos, const char *fn, char *value );
extern size_t ev3_multi_write_bool( uint8_t *sn, uint16_t pos, const char *fn, _Bool value );
extern size_t ev3_multi_write_int( uint8_t *sn, uint16_t pos, const char *fn, int value );
extern size_t ev3_multi_write_dword( uint8_t *sn, uint16_t pos, const char *fn, uint32_t value );
extern size_t ev3_multi_write_byte( uint8_t *sn, uint16_t pos, const char *fn, uint8_t value );
extern size_t ev3_multi_write_float( uint8_t *sn, uint16_t pos, const char *fn, float value );
extern size_t ev3_multi_write_char_array( uint8_t *sn, uint16_t pos, const char *fn, char *value );
extern size_t ev3_multi_write_byte_array( uint8_t *sn, uint16_t pos, const char *fn, uint8_t *value, size_t sz );
# 184 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3.h"
extern size_t ev3_read_binary( const char *fn, char *buf, size_t sz );
# 193 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3.h"
extern size_t ev3_read( const char *fn, char *buf, size_t sz );







extern size_t ev3_read_bool( const char *fn, _Bool *buf );







extern size_t ev3_read_int( const char *fn, int *buf );







extern size_t ev3_read_dword( const char *fn, uint32_t *buf );







extern size_t ev3_read_byte( const char *fn, uint8_t *buf );







extern size_t ev3_read_float( const char *fn, float *buf );

extern size_t ev3_read_char_array( const char *fn, char *buf, size_t sz );
extern size_t ev3_read_byte_array( const char *fn, uint8_t *buf, size_t sz );
# 245 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3.h"
extern size_t ev3_listdir( const char *fn, char *buf, size_t sz );






extern size_t ev3_read_keys( uint8_t *buf );





extern _Bool ev3_poweroff( void );
# 268 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3.h"
extern int ev3_string_suffix( const char *prefix, char **s, uint32_t *buf );
# 19 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.c" 2
# 1 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h" 1
# 59 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
typedef struct {
 INX_T type_inx;
 uint8_t port;
 uint8_t extport;
 uint8_t addr;

} EV3_PORT;
# 74 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern EV3_PORT ev3_port[ 64 ];




enum {
 PORT_TYPE__NONE_ = 0,

 BRICKPI_OUT_PORT,
 BRICKPI3_IN_PORT,
 HT_NXT_SMUX_PORT,
 EV3_OUTPUT_PORT,
 WEDO_PORT,
 EV3_INPUT_PORT,
 PISTORMS_OUT_PORT,
 BRICKPI3_OUT_PORT,
 PISTORMS_IN_PORT,
 BRICKPI_IN_PORT,
 MS_EV3_SMUX_PORT,
 MS_NXTMMX_OUT_PORT,

 PORT_TYPE__COUNT_,
 PORT_TYPE__UNKNOWN_ = PORT_TYPE__COUNT_
};




enum {
 PORT_MODE__NONE_ = 0,

 BRICKPI_OUT_PORT_TACHO_MOTOR, BRICKPI_OUT_TACHO_MOTOR = BRICKPI_OUT_PORT_TACHO_MOTOR,
 BRICKPI_OUT_PORT_DC_MOTOR, BRICKPI_OUT_DC_MOTOR = BRICKPI_OUT_PORT_DC_MOTOR,
 BRICKPI_OUT_PORT_LED, BRICKPI_OUT_LED = BRICKPI_OUT_PORT_LED,
 BRICKPI3_IN_PORT_NONE, BRICKPI3_IN_NONE = BRICKPI3_IN_PORT_NONE,
 BRICKPI3_IN_PORT_NXT_ANALOG, BRICKPI3_IN_NXT_ANALOG = BRICKPI3_IN_PORT_NXT_ANALOG,
 BRICKPI3_IN_PORT_NXT_COLOR, BRICKPI3_IN_NXT_COLOR = BRICKPI3_IN_PORT_NXT_COLOR,
 BRICKPI3_IN_PORT_NXT_I2C, BRICKPI3_IN_NXT_I2C = BRICKPI3_IN_PORT_NXT_I2C,
 BRICKPI3_IN_PORT_EV3_ANALOG, BRICKPI3_IN_EV3_ANALOG = BRICKPI3_IN_PORT_EV3_ANALOG,
 BRICKPI3_IN_PORT_EV3_UART, BRICKPI3_IN_EV3_UART = BRICKPI3_IN_PORT_EV3_UART,
 HT_NXT_SMUX_PORT_ANALOG, HT_NXT_SMUX_ANALOG = HT_NXT_SMUX_PORT_ANALOG,
 HT_NXT_SMUX_PORT_I2C, HT_NXT_SMUX_I2C = HT_NXT_SMUX_PORT_I2C,
 EV3_OUTPUT_PORT_AUTO, EV3_OUTPUT_AUTO = EV3_OUTPUT_PORT_AUTO,
 EV3_OUTPUT_PORT_TACHO_MOTOR, EV3_OUTPUT_TACHO_MOTOR = EV3_OUTPUT_PORT_TACHO_MOTOR,
 EV3_OUTPUT_PORT_DC_MOTOR, EV3_OUTPUT_DC_MOTOR = EV3_OUTPUT_PORT_DC_MOTOR,
 EV3_OUTPUT_PORT_LED, EV3_OUTPUT_LED = EV3_OUTPUT_PORT_LED,
 EV3_OUTPUT_PORT_RAW, EV3_OUTPUT_RAW = EV3_OUTPUT_PORT_RAW,
 WEDO_PORT_AUTO, WEDO_AUTO = WEDO_PORT_AUTO,
 EV3_INPUT_PORT_AUTO, EV3_INPUT_AUTO = EV3_INPUT_PORT_AUTO,
 EV3_INPUT_PORT_NXT_ANALOG, EV3_INPUT_NXT_ANALOG = EV3_INPUT_PORT_NXT_ANALOG,
 EV3_INPUT_PORT_NXT_COLOR, EV3_INPUT_NXT_COLOR = EV3_INPUT_PORT_NXT_COLOR,
 EV3_INPUT_PORT_NXT_I2C, EV3_INPUT_NXT_I2C = EV3_INPUT_PORT_NXT_I2C,
 EV3_INPUT_PORT_OTHER_I2C, EV3_INPUT_OTHER_I2C = EV3_INPUT_PORT_OTHER_I2C,
 EV3_INPUT_PORT_EV3_ANALOG, EV3_INPUT_EV3_ANALOG = EV3_INPUT_PORT_EV3_ANALOG,
 EV3_INPUT_PORT_EV3_UART, EV3_INPUT_EV3_UART = EV3_INPUT_PORT_EV3_UART,
 EV3_INPUT_PORT_OTHER_UART, EV3_INPUT_OTHER_UART = EV3_INPUT_PORT_OTHER_UART,
 EV3_INPUT_PORT_RAW, EV3_INPUT_RAW = EV3_INPUT_PORT_RAW,
 PISTORMS_OUT_PORT_TACHO_MOTOR, PISTORMS_OUT_TACHO_MOTOR = PISTORMS_OUT_PORT_TACHO_MOTOR,
 BRICKPI3_OUT_PORT_TACHO_MOTOR, BRICKPI3_OUT_TACHO_MOTOR = BRICKPI3_OUT_PORT_TACHO_MOTOR,
 BRICKPI3_OUT_PORT_DC_MOTOR, BRICKPI3_OUT_DC_MOTOR = BRICKPI3_OUT_PORT_DC_MOTOR,
 BRICKPI3_OUT_PORT_LED, BRICKPI3_OUT_LED = BRICKPI3_OUT_PORT_LED,
 PISTORMS_IN_PORT_NONE, PISTORMS_IN_NONE = PISTORMS_IN_PORT_NONE,
 PISTORMS_IN_PORT_NXT_ANALOG, PISTORMS_IN_NXT_ANALOG = PISTORMS_IN_PORT_NXT_ANALOG,
 PISTORMS_IN_PORT_NXT_COLOR, PISTORMS_IN_NXT_COLOR = PISTORMS_IN_PORT_NXT_COLOR,
 PISTORMS_IN_PORT_I2C_THRU, PISTORMS_IN_I2C_THRU = PISTORMS_IN_PORT_I2C_THRU,
 PISTORMS_IN_PORT_EV3_ANALOG, PISTORMS_IN_EV3_ANALOG = PISTORMS_IN_PORT_EV3_ANALOG,
 PISTORMS_IN_PORT_EV3_UART, PISTORMS_IN_EV3_UART = PISTORMS_IN_PORT_EV3_UART,
 BRICKPI_IN_PORT_NONE, BRICKPI_IN_NONE = BRICKPI_IN_PORT_NONE,
 BRICKPI_IN_PORT_NXT_ANALOG, BRICKPI_IN_NXT_ANALOG = BRICKPI_IN_PORT_NXT_ANALOG,
 BRICKPI_IN_PORT_NXT_COLOR, BRICKPI_IN_NXT_COLOR = BRICKPI_IN_PORT_NXT_COLOR,
 BRICKPI_IN_PORT_NXT_I2C, BRICKPI_IN_NXT_I2C = BRICKPI_IN_PORT_NXT_I2C,
 BRICKPI_IN_PORT_EV3_ANALOG, BRICKPI_IN_EV3_ANALOG = BRICKPI_IN_PORT_EV3_ANALOG,
 BRICKPI_IN_PORT_EV3_UART, BRICKPI_IN_EV3_UART = BRICKPI_IN_PORT_EV3_UART,
 MS_EV3_SMUX_PORT_UART, MS_EV3_SMUX_UART = MS_EV3_SMUX_PORT_UART,
 MS_EV3_SMUX_PORT_ANALOG, MS_EV3_SMUX_ANALOG = MS_EV3_SMUX_PORT_ANALOG,
 MS_NXTMMX_OUT_PORT_TACHO_MOTOR, MS_NXTMMX_OUT_TACHO_MOTOR = MS_NXTMMX_OUT_PORT_TACHO_MOTOR,
 PORT_MODE__COUNT_,
 PORT_MODE__UNKNOWN_ = PORT_MODE__COUNT_
};
# 161 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern size_t get_port_address( uint8_t sn, char *buf, size_t sz );
# 170 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern size_t get_port_driver_name( uint8_t sn, char *buf, size_t sz );
# 179 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern size_t get_port_mode( uint8_t sn, char *buf, size_t sz );
# 188 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern size_t set_port_mode( uint8_t sn, char *value );
# 197 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern size_t multi_set_port_mode( uint8_t *sn, char *value );
# 206 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern size_t get_port_modes( uint8_t sn, char *buf, size_t sz );
# 215 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern size_t set_port_set_device( uint8_t sn, char *value );
# 224 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern size_t multi_set_port_set_device( uint8_t *sn, char *value );
# 233 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern size_t get_port_status( uint8_t sn, char *buf, size_t sz );






extern const char *ev3_port_type( INX_T type_inx );






extern INX_T get_port_type_inx( uint8_t sn );







extern size_t get_port_desc( uint8_t sn, EV3_PORT *desc );






extern EV3_PORT *ev3_port_desc( uint8_t sn );






extern INX_T ev3_port_desc_type_inx( uint8_t sn );






extern uint8_t ev3_port_desc_port( uint8_t sn );






extern uint8_t ev3_port_desc_extport( uint8_t sn );






extern uint8_t ev3_port_desc_addr( uint8_t sn );







extern char *ev3_port_port_name( uint8_t sn, char *buf );
# 307 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern _Bool ev3_search_port_type( INX_T type_inx, uint8_t *sn, uint8_t from );
# 317 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern _Bool ev3_search_port_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );






extern const char *ev3_port_mode( INX_T mode_inx );







extern INX_T get_port_mode_inx_of_type( uint8_t sn, INX_T type_inx );
# 341 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern INX_T get_port_mode_inx( uint8_t sn );







extern size_t set_port_mode_inx( uint8_t sn, INX_T mode_inx );







extern size_t multi_set_port_mode_inx( uint8_t *sn, INX_T mode_inx );





extern int ev3_port_init( void );
# 409 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern uint8_t ev3_search_port( uint8_t port, uint8_t extport );
# 418 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern void ev3_parse_port_name( char *name, uint8_t *port, uint8_t *extport, uint8_t *addr );
# 428 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_port.h"
extern char *ev3_port_name( uint8_t port, uint8_t extport, uint8_t addr, char *buf );
# 20 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.c" 2
# 1 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h" 1
# 59 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
typedef struct {
 INX_T type_inx;
 uint8_t port;
 uint8_t extport;
 uint8_t addr;

} EV3_SENSOR;
# 74 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
EV3_SENSOR ev3_sensor[ 64 ];




enum {
 SENSOR_TYPE__NONE_ = 0,

 EV3_ANALOG_XX,
 NXT_ANALOG,
 PIXY_LEGO,
 DI_DFLEX,
 FCL_9DOF,
 FCL_ADC,
 FCL_ALTITUDE,
 FCL_GESTURE,
 FCL_HUMIDITY,
 FCL_IR,
 FCL_LIGHT,
 HT_NXT_COLOR,
 HT_NXT_ANGLE,
 HT_NXT_ACCEL,
 HT_NXT_BAROMETRIC,
 HT_NXT_COLOR_V2,
 HT_NXT_EOPD,
 HT_NXT_FORCE,
 HT_NXT_GYRO,
 HT_NXT_IR_LINK,
 HT_NXT_IR_RECEIVER,
 HT_NXT_PIR,
 HT_NXT_COMPASS,
 HT_NXT_MAG,
 HT_NXT_IR_SEEK_V2,
 HT_NXT_SMUX,
 HT_SUPER_PRO,
 LEGO_EV3_US,
 LEGO_EV3_GYRO,
 LEGO_EV3_COLOR,
 LEGO_EV3_TOUCH,
 LEGO_EV3_IR,
 WEDO_HUB,
 WEDO_MOTION,
 WEDO_TILT,
 LEGO_POWER_STORAGE,
 LEGO_NXT_TEMP,
 LEGO_NXT_TOUCH,
 LEGO_NXT_LIGHT,
 LEGO_NXT_SOUND,
 LEGO_NXT_US,
 MI_XG1300L,
 MS_ABSOLUTE_IMU,
 MS_ANGLE,
 MS_EV3_SMUX,
 MS_LIGHT_ARRAY,
 MS_LINE_LEADER,
 MS_NXTCAM,
 MS_NXTCAM5,
 MS_NXTMMX,
 MS_8CH_SERVO,
 MS_PPS58_NX,
 MS_PIXY_ADAPTER,
 MS_NXT_TOUCH_MUX,

 SENSOR_TYPE__COUNT_,
 SENSOR_TYPE__UNKNOWN_ = SENSOR_TYPE__COUNT_
};




enum {
 SENSOR_MODE__NONE_ = 0,

 EV3_ANALOG_XX_ANALOG,
 NXT_ANALOG_ANALOG_0,
 NXT_ANALOG_ANALOG_1,
 PIXY_LEGO_ALL,
 PIXY_LEGO_SIG1,
 PIXY_LEGO_SIG2,
 PIXY_LEGO_SIG3,
 PIXY_LEGO_SIG4,
 PIXY_LEGO_SIG5,
 PIXY_LEGO_SIG6,
 PIXY_LEGO_SIG7,
 DI_DFLEX_FLEX,
 FCL_9DOF_GYRO,
 FCL_9DOF_ACC,
 FCL_9DOF_MAGNET,
 FCL_ADC_CH1_VOLTAGE,
 FCL_ADC_CH2_VOLTAGE,
 FCL_ADC_VOLTAGE,
 FCL_ALTITUDE_PRESSURE,
 FCL_ALTITUDE_ALTITUDE,
 FCL_GESTURE_GESTURE,
 FCL_GESTURE_PROXIMITY,
 FCL_GESTURE_RGB_RAW,
 FCL_GESTURE_CLEAR,
 FCL_HUMIDITY_CENTIGRADE,
 FCL_HUMIDITY_FAHRENHEIT,
 FCL_HUMIDITY_HUMIDITY,
 FCL_IR_IR_DATA,
 FCL_LIGHT_ILLUMINANCE,
 HT_NXT_COLOR_COLOR,
 HT_NXT_COLOR_RED,
 HT_NXT_COLOR_GREEN,
 HT_NXT_COLOR_BLUE,
 HT_NXT_COLOR_RAW,
 HT_NXT_COLOR_NORM,
 HT_NXT_COLOR_ALL,
 HT_NXT_ANGLE_ANGLE,
 HT_NXT_ANGLE_ANGLE_ACC,
 HT_NXT_ANGLE_SPEED,
 HT_NXT_ACCEL_ACCEL,
 HT_NXT_ACCEL_ALL,
 HT_NXT_BAROMETRIC_PRESS,
 HT_NXT_BAROMETRIC_TEMP,
 HT_NXT_COLOR_V2_COLOR,
 HT_NXT_COLOR_V2_RED,
 HT_NXT_COLOR_V2_GREEN,
 HT_NXT_COLOR_V2_BLUE,
 HT_NXT_COLOR_V2_WHITE,
 HT_NXT_COLOR_V2_NORM,
 HT_NXT_COLOR_V2_ALL,
 HT_NXT_COLOR_V2_PASSIVE,
 HT_NXT_COLOR_V2_RAW,
 HT_NXT_EOPD_LONG,
 HT_NXT_EOPD_SHORT,
 HT_NXT_FORCE_FORCE,
 HT_NXT_GYRO_GYRO,
 HT_NXT_IR_LINK_IRLINK,
 HT_NXT_IR_RECEIVER_1_MOTOR,
 HT_NXT_IR_RECEIVER_8_MOTOR,
 HT_NXT_PIR_PROX,
 HT_NXT_COMPASS_COMPASS,
 HT_NXT_MAG_MAG,
 HT_NXT_IR_SEEK_V2_DC,
 HT_NXT_IR_SEEK_V2_AC,
 HT_NXT_IR_SEEK_V2_DC_ALL,
 HT_NXT_IR_SEEK_V2_AC_ALL,
 HT_NXT_SMUX_MUX,
 HT_SUPER_PRO_AIN,
 HT_SUPER_PRO_DIN,
 HT_SUPER_PRO_DOUT,
 HT_SUPER_PRO_DCTRL,
 HT_SUPER_PRO_STROBE,
 HT_SUPER_PRO_LED,
 HT_SUPER_PRO_AOUT_0,
 HT_SUPER_PRO_AOUT_1,
 LEGO_EV3_US_US_DIST_CM, US_US_DIST_CM = LEGO_EV3_US_US_DIST_CM,
 LEGO_EV3_US_US_DIST_IN, US_US_DIST_IN = LEGO_EV3_US_US_DIST_IN,
 LEGO_EV3_US_US_LISTEN, US_US_LISTEN = LEGO_EV3_US_US_LISTEN,
 LEGO_EV3_US_US_SI_CM, US_US_SI_CM = LEGO_EV3_US_US_SI_CM,
 LEGO_EV3_US_US_SI_IN, US_US_SI_IN = LEGO_EV3_US_US_SI_IN,
 LEGO_EV3_US_US_DC_CM, US_US_DC_CM = LEGO_EV3_US_US_DC_CM,
 LEGO_EV3_US_US_DC_IN, US_US_DC_IN = LEGO_EV3_US_US_DC_IN,
 LEGO_EV3_GYRO_GYRO_ANG, GYRO_GYRO_ANG = LEGO_EV3_GYRO_GYRO_ANG,
 LEGO_EV3_GYRO_GYRO_RATE, GYRO_GYRO_RATE = LEGO_EV3_GYRO_GYRO_RATE,
 LEGO_EV3_GYRO_GYRO_FAS, GYRO_GYRO_FAS = LEGO_EV3_GYRO_GYRO_FAS,
 LEGO_EV3_GYRO_GYRO_G_AND_A, GYRO_GYRO_G_AND_A = LEGO_EV3_GYRO_GYRO_G_AND_A,
 LEGO_EV3_GYRO_GYRO_CAL, GYRO_GYRO_CAL = LEGO_EV3_GYRO_GYRO_CAL,
 LEGO_EV3_COLOR_COL_REFLECT, COLOR_COL_REFLECT = LEGO_EV3_COLOR_COL_REFLECT,
 LEGO_EV3_COLOR_COL_AMBIENT, COLOR_COL_AMBIENT = LEGO_EV3_COLOR_COL_AMBIENT,
 LEGO_EV3_COLOR_COL_COLOR, COLOR_COL_COLOR = LEGO_EV3_COLOR_COL_COLOR,
 LEGO_EV3_COLOR_REF_RAW, COLOR_REF_RAW = LEGO_EV3_COLOR_REF_RAW,
 LEGO_EV3_COLOR_RGB_RAW, COLOR_RGB_RAW = LEGO_EV3_COLOR_RGB_RAW,
 LEGO_EV3_COLOR_COL_CAL, COLOR_COL_CAL = LEGO_EV3_COLOR_COL_CAL,
 LEGO_EV3_TOUCH_TOUCH, TOUCH_TOUCH = LEGO_EV3_TOUCH_TOUCH,
 LEGO_EV3_IR_IR_PROX, IR_IR_PROX = LEGO_EV3_IR_IR_PROX,
 LEGO_EV3_IR_IR_SEEK, IR_IR_SEEK = LEGO_EV3_IR_IR_SEEK,
 LEGO_EV3_IR_IR_REMOTE, IR_IR_REMOTE = LEGO_EV3_IR_IR_REMOTE,
 LEGO_EV3_IR_IR_REM_A, IR_IR_REM_A = LEGO_EV3_IR_IR_REM_A,
 LEGO_EV3_IR_IR_S_ALT, IR_IR_S_ALT = LEGO_EV3_IR_IR_S_ALT,
 LEGO_EV3_IR_IR_CAL, IR_IR_CAL = LEGO_EV3_IR_IR_CAL,
 WEDO_HUB_HUB,
 WEDO_MOTION_PROX,
 WEDO_MOTION_RAW,
 WEDO_TILT_TILT,
 WEDO_TILT_TILT_AXIS,
 WEDO_TILT_RAW,
 LEGO_POWER_STORAGE_IN_VOLT,
 LEGO_POWER_STORAGE_IN_AMP,
 LEGO_POWER_STORAGE_OUT_VOLT,
 LEGO_POWER_STORAGE_OUT_AMP,
 LEGO_POWER_STORAGE_JOULE,
 LEGO_POWER_STORAGE_IN_WATT,
 LEGO_POWER_STORAGE_OUT_WATT,
 LEGO_POWER_STORAGE_ALL,
 LEGO_NXT_TEMP_NXT_TEMP_C,
 LEGO_NXT_TEMP_NXT_TEMP_F,
 LEGO_NXT_TOUCH_TOUCH,
 LEGO_NXT_LIGHT_REFLECT,
 LEGO_NXT_LIGHT_AMBIENT,
 LEGO_NXT_SOUND_DB,
 LEGO_NXT_SOUND_DBA,
 LEGO_NXT_US_US_DIST_CM,
 LEGO_NXT_US_US_DIST_IN,
 LEGO_NXT_US_US_SI_CM,
 LEGO_NXT_US_US_SI_IN,
 LEGO_NXT_US_US_LISTEN,
 MI_XG1300L_ANGLE,
 MI_XG1300L_SPEED,
 MI_XG1300L_ACCEL,
 MI_XG1300L_ALL,
 MS_ABSOLUTE_IMU_TILT,
 MS_ABSOLUTE_IMU_ACCEL,
 MS_ABSOLUTE_IMU_COMPASS,
 MS_ABSOLUTE_IMU_MAG,
 MS_ABSOLUTE_IMU_GYRO,
 MS_ABSOLUTE_IMU_ALL,
 MS_ANGLE_ANGLE,
 MS_ANGLE_ANGLE2,
 MS_ANGLE_SPEED,
 MS_ANGLE_ALL,
 MS_EV3_SMUX_MUX,
 MS_LIGHT_ARRAY_CAL,
 MS_LIGHT_ARRAY_RAW,
 MS_LINE_LEADER_PID,
 MS_LINE_LEADER_PID_ALL,
 MS_LINE_LEADER_CAL,
 MS_LINE_LEADER_RAW,
 MS_NXTCAM_TRACK,
 MS_NXTCAM5_TRACK,
 MS_NXTMMX_STATUS,
 MS_NXTMMX_STATUS_OLD,
 MS_8CH_SERVO_V3,
 MS_8CH_SERVO_OLD,
 MS_PPS58_NX_RAW,
 MS_PPS58_NX_ABS_PSI,
 MS_PPS58_NX_ABS_MBAR,
 MS_PPS58_NX_ABS_KPA,
 MS_PPS58_NX_REL_PSI,
 MS_PPS58_NX_REL_MBAR,
 MS_PPS58_NX_REL_KPA,
 MS_PIXY_ADAPTER_TRACK,
 MS_NXT_TOUCH_MUX_TOUCH_MUX,
 SENSOR_MODE__COUNT_,
 SENSOR_MODE__UNKNOWN_ = SENSOR_MODE__COUNT_
};




enum {
 SENSOR_COMMAND__NONE_ = 0,

 HT_NXT_ANGLE_RESET,
 HT_NXT_ANGLE_CAL,
 HT_NXT_SMUX_HALT,
 HT_NXT_SMUX_DETECT,
 HT_NXT_SMUX_RUN,
 WEDO_HUB_OUT_OFF,
 WEDO_HUB_OUT_ON,
 WEDO_HUB_CLEAR_ERR,
 MI_XG1300L_RESET,
 MI_XG1300L_ACCEL_2G,
 MI_XG1300L_ACCEL_4G,
 MI_XG1300L_ACCEL_8G,
 MS_ABSOLUTE_IMU_BEGIN_COMP_CAL,
 MS_ABSOLUTE_IMU_END_COMP_CAL,
 MS_ABSOLUTE_IMU_ACCEL_2G,
 MS_ABSOLUTE_IMU_ACCEL_4G,
 MS_ABSOLUTE_IMU_ACCEL_8G,
 MS_ABSOLUTE_IMU_ACCEL_16G,
 MS_ANGLE_RESET,
 MS_LIGHT_ARRAY_CAL_WHITE,
 MS_LIGHT_ARRAY_CAL_BLACK,
 MS_LIGHT_ARRAY_SLEEP,
 MS_LIGHT_ARRAY_WAKE,
 MS_LIGHT_ARRAY_60HZ,
 MS_LIGHT_ARRAY_50HZ,
 MS_LIGHT_ARRAY_UNIVERSAL,
 MS_LINE_LEADER_CAL_WHITE,
 MS_LINE_LEADER_CAL_BLACK,
 MS_LINE_LEADER_SLEEP,
 MS_LINE_LEADER_WAKE,
 MS_LINE_LEADER_INV_COL,
 MS_LINE_LEADER_RST_COL,
 MS_LINE_LEADER_SNAP,
 MS_LINE_LEADER_60HZ,
 MS_LINE_LEADER_50HZ,
 MS_LINE_LEADER_UNIVERSAL,
 MS_NXTCAM_TRACK_ON,
 MS_NXTCAM_TRACK_OFF,
 MS_NXTCAM_TRACK_OBJ,
 MS_NXTCAM_TRACK_LINE,
 MS_NXTCAM_SORT_SIZE,
 MS_NXTCAM_SORT_COL,
 MS_NXTCAM5_TRACK_OBJ,
 MS_NXTCAM5_TRACK_FACE,
 MS_NXTCAM5_MULTI_MOVIE,
 MS_NXTCAM5_MOVIE,
 MS_NXTCAM5_PICTURE,
 MS_NXTCAM5_TRACK_EYE,
 MS_NXTCAM5_TRACK_QR,
 MS_NXTCAM5_TRACK_LINE,
 MS_PPS58_NX_ZERO,
 MS_PIXY_ADAPTER_SORT_SIZE,
 MS_PIXY_ADAPTER_SORT_COL,
 SENSOR_COMMAND__COUNT_,
 SENSOR_COMMAND__UNKNOWN_ = SENSOR_COMMAND__COUNT_
};
# 383 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_address( uint8_t sn, char *buf, size_t sz );
# 392 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_bin_data( uint8_t sn, byte *buf, size_t sz );
# 401 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t set_sensor_bin_data( uint8_t sn, byte *value, size_t sz );
# 410 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t multi_set_sensor_bin_data( uint8_t *sn, byte *value, size_t sz );
# 419 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_bin_data_format( uint8_t sn, char *buf, size_t sz );
# 428 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t set_sensor_command( uint8_t sn, char *value );
# 437 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t multi_set_sensor_command( uint8_t *sn, char *value );
# 446 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_commands( uint8_t sn, char *buf, size_t sz );
# 455 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_direct( uint8_t sn, char *buf, size_t sz );
# 464 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t set_sensor_direct( uint8_t sn, char *value );
# 473 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t multi_set_sensor_direct( uint8_t *sn, char *value );
# 482 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_decimals( uint8_t sn, dword *buf );
# 491 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_driver_name( uint8_t sn, char *buf, size_t sz );
# 500 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_fw_version( uint8_t sn, char *buf, size_t sz );
# 509 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_mode( uint8_t sn, char *buf, size_t sz );
# 518 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t set_sensor_mode( uint8_t sn, char *value );
# 527 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t multi_set_sensor_mode( uint8_t *sn, char *value );
# 536 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_modes( uint8_t sn, char *buf, size_t sz );
# 545 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_num_values( uint8_t sn, dword *buf );
# 554 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_poll_ms( uint8_t sn, dword *buf );
# 563 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t set_sensor_poll_ms( uint8_t sn, dword value );
# 572 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t multi_set_sensor_poll_ms( uint8_t *sn, dword value );
# 581 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_units( uint8_t sn, char *buf, size_t sz );
# 590 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_value0( uint8_t sn, float *buf );
# 599 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_value1( uint8_t sn, float *buf );
# 608 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_value2( uint8_t sn, float *buf );
# 617 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_value3( uint8_t sn, float *buf );
# 626 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_value4( uint8_t sn, float *buf );
# 635 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_value5( uint8_t sn, float *buf );
# 644 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_value6( uint8_t sn, float *buf );
# 653 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_value7( uint8_t sn, float *buf );
# 662 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_text_value( uint8_t sn, char *buf, size_t sz );
# 672 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern size_t get_sensor_value( uint8_t inx, uint8_t sn, int *buf );






extern const char *ev3_sensor_type( INX_T type_inx );






extern INX_T get_sensor_type_inx( uint8_t sn );







extern size_t get_sensor_desc( uint8_t sn, EV3_SENSOR *desc );






extern EV3_SENSOR *ev3_sensor_desc( uint8_t sn );






extern INX_T ev3_sensor_desc_type_inx( uint8_t sn );






extern uint8_t ev3_sensor_desc_port( uint8_t sn );






extern uint8_t ev3_sensor_desc_extport( uint8_t sn );






extern uint8_t ev3_sensor_desc_addr( uint8_t sn );







extern char *ev3_sensor_port_name( uint8_t sn, char *buf );
# 746 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern _Bool ev3_search_sensor( INX_T type_inx, uint8_t *sn, uint8_t from );
# 756 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern _Bool ev3_search_sensor_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from );






extern const char *ev3_sensor_mode( INX_T mode_inx );







extern INX_T get_sensor_mode_inx_of_type( uint8_t sn, INX_T type_inx );
# 780 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.h"
extern INX_T get_sensor_mode_inx( uint8_t sn );







extern size_t set_sensor_mode_inx( uint8_t sn, INX_T mode_inx );







extern size_t multi_set_sensor_mode_inx( uint8_t *sn, INX_T mode_inx );






extern const char *ev3_sensor_command( INX_T command_inx );







extern size_t set_sensor_command_inx( uint8_t sn, INX_T command_inx );







extern size_t multi_set_sensor_command_inx( uint8_t *sn, INX_T command_inx );





extern int ev3_sensor_init( void );




enum {
 IR_REMOTE__NONE_ = 0,

 RED_UP = 1,
 RED_DOWN = 2,
 BLUE_UP = 3,
 BLUE_DOWN = 4,
 RED_UP_BLUE_UP = 5,
 RED_UP_BLUE_DOWN = 6,
 RED_DOWN_BLUE_UP = 7,
 RED_DOWN_BLUE_DOWN = 8,
 BEACON_MODE_ON = 9,
 RED_UP_RED_DOWN = 10,
 BLUE_UP_BLUE_DOWN = 11,
};
# 21 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.c" 2
# 51 "C:/Users/Patrick/Documents/Progammieren/C/herter/robot/ev3dev-c/source/ev3/ev3_sensor.c"
size_t get_sensor_address( uint8_t sn, char *buf, size_t sz )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "address";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_char_array( s, buf, sz );
}

size_t get_sensor_bin_data( uint8_t sn, byte *buf, size_t sz )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "bin_data";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_byte_array( s, buf, sz );
}

size_t set_sensor_bin_data( uint8_t sn, byte *value, size_t sz )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "bin_data";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_write_byte_array( s, value, sz );
}

size_t multi_set_sensor_bin_data( uint8_t *sn, byte *value, size_t sz )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "bin_data";

 return ev3_multi_write_byte_array( sn, 29, s, value, sz );
}

size_t get_sensor_bin_data_format( uint8_t sn, char *buf, size_t sz )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "bin_data_format";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_char_array( s, buf, sz );
}

size_t set_sensor_command( uint8_t sn, char *value )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "command";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_write_char_array( s, value );
}

size_t multi_set_sensor_command( uint8_t *sn, char *value )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "command";

 return ev3_multi_write_char_array( sn, 29, s, value );
}

size_t get_sensor_commands( uint8_t sn, char *buf, size_t sz )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "commands";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_char_array( s, buf, sz );
}

size_t get_sensor_direct( uint8_t sn, char *buf, size_t sz )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "direct";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_char_array( s, buf, sz );
}

size_t set_sensor_direct( uint8_t sn, char *value )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "direct";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_write_char_array( s, value );
}

size_t multi_set_sensor_direct( uint8_t *sn, char *value )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "direct";

 return ev3_multi_write_char_array( sn, 29, s, value );
}

size_t get_sensor_decimals( uint8_t sn, dword *buf )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "decimals";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_dword( s, buf );
}

size_t get_sensor_driver_name( uint8_t sn, char *buf, size_t sz )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "driver_name";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_char_array( s, buf, sz );
}

size_t get_sensor_fw_version( uint8_t sn, char *buf, size_t sz )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "fw_version";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_char_array( s, buf, sz );
}

size_t get_sensor_mode( uint8_t sn, char *buf, size_t sz )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "mode";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_char_array( s, buf, sz );
}

size_t set_sensor_mode( uint8_t sn, char *value )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "mode";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_write_char_array( s, value );
}

size_t multi_set_sensor_mode( uint8_t *sn, char *value )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "mode";

 return ev3_multi_write_char_array( sn, 29, s, value );
}

size_t get_sensor_modes( uint8_t sn, char *buf, size_t sz )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "modes";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_char_array( s, buf, sz );
}

size_t get_sensor_num_values( uint8_t sn, dword *buf )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "num_values";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_dword( s, buf );
}

size_t get_sensor_poll_ms( uint8_t sn, dword *buf )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "poll_ms";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_dword( s, buf );
}

size_t set_sensor_poll_ms( uint8_t sn, dword value )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "poll_ms";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_write_dword( s, value );
}

size_t multi_set_sensor_poll_ms( uint8_t *sn, dword value )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "poll_ms";

 return ev3_multi_write_dword( sn, 29, s, value );
}

size_t get_sensor_units( uint8_t sn, char *buf, size_t sz )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "units";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_char_array( s, buf, sz );
}

size_t get_sensor_value0( uint8_t sn, float *buf )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "value0";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_float( s, buf );
}

size_t get_sensor_value1( uint8_t sn, float *buf )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "value1";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_float( s, buf );
}

size_t get_sensor_value2( uint8_t sn, float *buf )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "value2";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_float( s, buf );
}

size_t get_sensor_value3( uint8_t sn, float *buf )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "value3";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_float( s, buf );
}

size_t get_sensor_value4( uint8_t sn, float *buf )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "value4";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_float( s, buf );
}

size_t get_sensor_value5( uint8_t sn, float *buf )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "value5";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_float( s, buf );
}

size_t get_sensor_value6( uint8_t sn, float *buf )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "value6";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_float( s, buf );
}

size_t get_sensor_value7( uint8_t sn, float *buf )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "value7";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_float( s, buf );
}

size_t get_sensor_text_value( uint8_t sn, char *buf, size_t sz )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "text_value";
 *modp_uitoa10( sn, s + 29 ) = '/';

 return ev3_read_char_array( s, buf, sz );
}

size_t get_sensor_value( uint8_t inx, uint8_t sn, int *buf )
{
 char s[] = "/sys/class/lego-sensor/sensor" "///" "value" "    ";

 if ( inx > 8 ) return ( 0 );

 *modp_uitoa10( sn, s + 29 ) = '/';
 modp_uitoa10( inx, s + 29 + 3 + 5 );

 return ev3_read_int( s, buf );
}

const char *ev3_sensor_type( INX_T type_inx )
{
 switch ( type_inx ) {
 case EV3_ANALOG_XX:
  return "ev3-analog-XX";
 case NXT_ANALOG:
  return "nxt-analog";
 case PIXY_LEGO:
  return "pixy-lego";
 case DI_DFLEX:
  return "di-dflex";
 case FCL_9DOF:
  return "fcl-9dof";
 case FCL_ADC:
  return "fcl-adc";
 case FCL_ALTITUDE:
  return "fcl-altitude";
 case FCL_GESTURE:
  return "fcl-gesture";
 case FCL_HUMIDITY:
  return "fcl-humidity";
 case FCL_IR:
  return "fcl-ir";
 case FCL_LIGHT:
  return "fcl-light";
 case HT_NXT_COLOR:
  return "ht-nxt-color";
 case HT_NXT_ANGLE:
  return "ht-nxt-angle";
 case HT_NXT_ACCEL:
  return "ht-nxt-accel";
 case HT_NXT_BAROMETRIC:
  return "ht-nxt-barometric";
 case HT_NXT_COLOR_V2:
  return "ht-nxt-color-v2";
 case HT_NXT_EOPD:
  return "ht-nxt-eopd";
 case HT_NXT_FORCE:
  return "ht-nxt-force";
 case HT_NXT_GYRO:
  return "ht-nxt-gyro";
 case HT_NXT_IR_LINK:
  return "ht-nxt-ir-link";
 case HT_NXT_IR_RECEIVER:
  return "ht-nxt-ir-receiver";
 case HT_NXT_PIR:
  return "ht-nxt-pir";
 case HT_NXT_COMPASS:
  return "ht-nxt-compass";
 case HT_NXT_MAG:
  return "ht-nxt-mag";
 case HT_NXT_IR_SEEK_V2:
  return "ht-nxt-ir-seek-v2";
 case HT_NXT_SMUX:
  return "ht-nxt-smux";
 case HT_SUPER_PRO:
  return "ht-super-pro";
 case LEGO_EV3_US:
  return "lego-ev3-us";
 case LEGO_EV3_GYRO:
  return "lego-ev3-gyro";
 case LEGO_EV3_COLOR:
  return "lego-ev3-color";
 case LEGO_EV3_TOUCH:
  return "lego-ev3-touch";
 case LEGO_EV3_IR:
  return "lego-ev3-ir";
 case WEDO_HUB:
  return "wedo-hub";
 case WEDO_MOTION:
  return "wedo-motion";
 case WEDO_TILT:
  return "wedo-tilt";
 case LEGO_POWER_STORAGE:
  return "lego-power-storage";
 case LEGO_NXT_TEMP:
  return "lego-nxt-temp";
 case LEGO_NXT_TOUCH:
  return "lego-nxt-touch";
 case LEGO_NXT_LIGHT:
  return "lego-nxt-light";
 case LEGO_NXT_SOUND:
  return "lego-nxt-sound";
 case LEGO_NXT_US:
  return "lego-nxt-us";
 case MI_XG1300L:
  return "mi-xg1300l";
 case MS_ABSOLUTE_IMU:
  return "ms-absolute-imu";
 case MS_ANGLE:
  return "ms-angle";
 case MS_EV3_SMUX:
  return "ms-ev3-smux";
 case MS_LIGHT_ARRAY:
  return "ms-light-array";
 case MS_LINE_LEADER:
  return "ms-line-leader";
 case MS_NXTCAM:
  return "ms-nxtcam";
 case MS_NXTCAM5:
  return "ms-nxtcam5";
 case MS_NXTMMX:
  return "ms-nxtmmx";
 case MS_8CH_SERVO:
  return "ms-8ch-servo";
 case MS_PPS58_NX:
  return "ms-pps58-nx";
 case MS_PIXY_ADAPTER:
  return "ms-pixy-adapter";
 case MS_NXT_TOUCH_MUX:
  return "ms-nxt-touch-mux";

 }
 return ( "<unknown>" );
}

INX_T get_sensor_type_inx( uint8_t sn )
{
 char buf[ 64 ];

 if ( !get_sensor_driver_name( sn, buf, sizeof( buf ))) return ( SENSOR_TYPE__NONE_ );

 switch ( crc32( 0, buf, strlen( buf ))) {
 case 0x9aaef5b7L:
  return EV3_ANALOG_XX;
 case 0xf7e1ce2cL:
  return NXT_ANALOG;
 case 0xdba885c2L:
  return PIXY_LEGO;
 case 0xe1f9430cL:
  return DI_DFLEX;
 case 0xbd6636bL:
  return FCL_9DOF;
 case 0x69cf09acL:
  return FCL_ADC;
 case 0x130104efL:
  return FCL_ALTITUDE;
 case 0xffe329dL:
  return FCL_GESTURE;
 case 0xc137d61fL:
  return FCL_HUMIDITY;
 case 0xfaac1d8fL:
  return FCL_IR;
 case 0xcd08d04bL:
  return FCL_LIGHT;
 case 0x49a6f8bfL:
  return HT_NXT_COLOR;
 case 0x2f71f55fL:
  return HT_NXT_ANGLE;
 case 0x720c86b3L:
  return HT_NXT_ACCEL;
 case 0xd5e63331L:
  return HT_NXT_BAROMETRIC;
 case 0x53b4575dL:
  return HT_NXT_COLOR_V2;
 case 0x941b59bbL:
  return HT_NXT_EOPD;
 case 0xb898337eL:
  return HT_NXT_FORCE;
 case 0x835df5f8L:
  return HT_NXT_GYRO;
 case 0xcc91b174L:
  return HT_NXT_IR_LINK;
 case 0xe6e18e7bL:
  return HT_NXT_IR_RECEIVER;
 case 0xd2b1e8faL:
  return HT_NXT_PIR;
 case 0x7786eae3L:
  return HT_NXT_COMPASS;
 case 0x634bb63aL:
  return HT_NXT_MAG;
 case 0xc6cc6277L:
  return HT_NXT_IR_SEEK_V2;
 case 0x8b9b2d9cL:
  return HT_NXT_SMUX;
 case 0x7da3900fL:
  return HT_SUPER_PRO;
 case 0xfec0d84eL:
  return LEGO_EV3_US;
 case 0x90a8a92dL:
  return LEGO_EV3_GYRO;
 case 0xbf0c2bb8L:
  return LEGO_EV3_COLOR;
 case 0x2fec4ea3L:
  return LEGO_EV3_TOUCH;
 case 0x6fb0b585L:
  return LEGO_EV3_IR;
 case 0x7756e9ceL:
  return WEDO_HUB;
 case 0x69420300L:
  return WEDO_MOTION;
 case 0x68b17c4bL:
  return WEDO_TILT;
 case 0xc62761bdL:
  return LEGO_POWER_STORAGE;
 case 0x986255fcL:
  return LEGO_NXT_TEMP;
 case 0x399f89bbL:
  return LEGO_NXT_TOUCH;
 case 0xa433f8beL:
  return LEGO_NXT_LIGHT;
 case 0x37a767cdL:
  return LEGO_NXT_SOUND;
 case 0x2df4f668L:
  return LEGO_NXT_US;
 case 0x5ea03e09L:
  return MI_XG1300L;
 case 0x33431ceaL:
  return MS_ABSOLUTE_IMU;
 case 0x8edd0449L:
  return MS_ANGLE;
 case 0x718c778L:
  return MS_EV3_SMUX;
 case 0xe337cbb5L:
  return MS_LIGHT_ARRAY;
 case 0xfae1806dL:
  return MS_LINE_LEADER;
 case 0xdde57ce7L:
  return MS_NXTCAM;
 case 0xba02b909L:
  return MS_NXTCAM5;
 case 0x1613fa0aL:
  return MS_NXTMMX;
 case 0x993a454aL:
  return MS_8CH_SERVO;
 case 0x9ae28244L:
  return MS_PPS58_NX;
 case 0x5b31dc33L:
  return MS_PIXY_ADAPTER;
 case 0xb033713fL:
  return MS_NXT_TOUCH_MUX;

 }

 return ( SENSOR_TYPE__UNKNOWN_ );
}

size_t get_sensor_desc( uint8_t sn, EV3_SENSOR *desc )
{
 uint8_t addr;
 char buf[ 32 ];

 desc->type_inx = get_sensor_type_inx( sn );
 if ( desc->type_inx == SENSOR_TYPE__NONE_ ) return ( 0 );

 if ( !get_sensor_address( sn, buf, sizeof( buf ))) return ( 0 );

 ev3_parse_port_name( buf, &desc->port, &desc->extport, &addr );
 desc->addr = addr;

 return ( sizeof( EV3_SENSOR ));
}

EV3_SENSOR *ev3_sensor_desc( uint8_t sn )
{
 if ( sn >= 64) sn = 64 - 1;
 return ( ev3_sensor + sn );
}

INX_T ev3_sensor_desc_type_inx( uint8_t sn )
{
 return ( ev3_sensor_desc( sn )->type_inx );
}

uint8_t ev3_sensor_desc_port( uint8_t sn )
{
 return ( ev3_sensor_desc( sn )->port );
}

uint8_t ev3_sensor_desc_extport( uint8_t sn )
{
 return ( ev3_sensor_desc( sn )->extport );
}

uint8_t ev3_sensor_desc_addr( uint8_t sn )
{
 return ( ev3_sensor_desc( sn )->addr );
}

char *ev3_sensor_port_name( uint8_t sn, char *buf )
{
 return ( ev3_port_name( ev3_sensor_desc( sn )->port, ev3_sensor_desc( sn )->extport, ev3_sensor_desc( sn )->addr, buf ));
}

_Bool ev3_search_sensor( INX_T type_inx, uint8_t *sn, uint8_t from )
{
 uint8_t _sn = from;

 while ( _sn < 64) {
  if ( ev3_sensor[ _sn ].type_inx == type_inx ) {
   *sn = _sn;
   return ( 1 );
  }
  ++_sn;
 }
 *sn = 64;
 return ( 0 );
}

_Bool ev3_search_sensor_plugged_in( uint8_t port, uint8_t extport, uint8_t *sn, uint8_t from )
{
 uint8_t _sn = from;

 while ( _sn < 64) {
  if ( ev3_sensor[ _sn ].port == port ) {
   if ( extport ) {
    if ( ev3_sensor[ _sn ].extport == extport ) {
     *sn = _sn;
     return ( 1 );
    }
   } else {
    *sn = _sn;
    return ( 1 );
   }
  }
  ++_sn;
 }
 *sn = 64;
 return ( 0 );
}

const char *ev3_sensor_mode( INX_T mode_inx )
{
 switch ( mode_inx ) {
 case EV3_ANALOG_XX_ANALOG:
  return "ANALOG";

 case NXT_ANALOG_ANALOG_0:
  return "ANALOG-0";
 case NXT_ANALOG_ANALOG_1:
  return "ANALOG-1";

 case PIXY_LEGO_ALL:
  return "ALL";
 case PIXY_LEGO_SIG1:
  return "SIG1";
 case PIXY_LEGO_SIG2:
  return "SIG2";
 case PIXY_LEGO_SIG3:
  return "SIG3";
 case PIXY_LEGO_SIG4:
  return "SIG4";
 case PIXY_LEGO_SIG5:
  return "SIG5";
 case PIXY_LEGO_SIG6:
  return "SIG6";
 case PIXY_LEGO_SIG7:
  return "SIG7";

 case DI_DFLEX_FLEX:
  return "FLEX";

 case FCL_9DOF_GYRO:
  return "GYRO";
 case FCL_9DOF_ACC:
  return "ACC";
 case FCL_9DOF_MAGNET:
  return "MAGNET";

 case FCL_ADC_CH1_VOLTAGE:
  return "CH1-VOLTAGE";
 case FCL_ADC_CH2_VOLTAGE:
  return "CH2-VOLTAGE";
 case FCL_ADC_VOLTAGE:
  return "VOLTAGE";

 case FCL_ALTITUDE_PRESSURE:
  return "PRESSURE";
 case FCL_ALTITUDE_ALTITUDE:
  return "ALTITUDE";

 case FCL_GESTURE_GESTURE:
  return "GESTURE";
 case FCL_GESTURE_PROXIMITY:
  return "PROXIMITY";
 case FCL_GESTURE_RGB_RAW:
  return "RGB-RAW";
 case FCL_GESTURE_CLEAR:
  return "CLEAR";

 case FCL_HUMIDITY_CENTIGRADE:
  return "CENTIGRADE";
 case FCL_HUMIDITY_FAHRENHEIT:
  return "FAHRENHEIT";
 case FCL_HUMIDITY_HUMIDITY:
  return "HUMIDITY";

 case FCL_IR_IR_DATA:
  return "IR DATA";

 case FCL_LIGHT_ILLUMINANCE:
  return "ILLUMINANCE";

 case HT_NXT_COLOR_COLOR:
  return "COLOR";
 case HT_NXT_COLOR_RED:
  return "RED";
 case HT_NXT_COLOR_GREEN:
  return "GREEN";
 case HT_NXT_COLOR_BLUE:
  return "BLUE";
 case HT_NXT_COLOR_RAW:
  return "RAW";
 case HT_NXT_COLOR_NORM:
  return "NORM";
 case HT_NXT_COLOR_ALL:
  return "ALL";

 case HT_NXT_ANGLE_ANGLE:
  return "ANGLE";
 case HT_NXT_ANGLE_ANGLE_ACC:
  return "ANGLE-ACC";
 case HT_NXT_ANGLE_SPEED:
  return "SPEED";

 case HT_NXT_ACCEL_ACCEL:
  return "ACCEL";
 case HT_NXT_ACCEL_ALL:
  return "ALL";

 case HT_NXT_BAROMETRIC_PRESS:
  return "PRESS";
 case HT_NXT_BAROMETRIC_TEMP:
  return "TEMP";

 case HT_NXT_COLOR_V2_COLOR:
  return "COLOR";
 case HT_NXT_COLOR_V2_RED:
  return "RED";
 case HT_NXT_COLOR_V2_GREEN:
  return "GREEN";
 case HT_NXT_COLOR_V2_BLUE:
  return "BLUE";
 case HT_NXT_COLOR_V2_WHITE:
  return "WHITE";
 case HT_NXT_COLOR_V2_NORM:
  return "NORM";
 case HT_NXT_COLOR_V2_ALL:
  return "ALL";
 case HT_NXT_COLOR_V2_PASSIVE:
  return "PASSIVE";
 case HT_NXT_COLOR_V2_RAW:
  return "RAW";

 case HT_NXT_EOPD_LONG:
  return "LONG";
 case HT_NXT_EOPD_SHORT:
  return "SHORT";

 case HT_NXT_FORCE_FORCE:
  return "FORCE";

 case HT_NXT_GYRO_GYRO:
  return "GYRO";

 case HT_NXT_IR_LINK_IRLINK:
  return "IRLINK";

 case HT_NXT_IR_RECEIVER_1_MOTOR:
  return "1-MOTOR";
 case HT_NXT_IR_RECEIVER_8_MOTOR:
  return "8-MOTOR";

 case HT_NXT_PIR_PROX:
  return "PROX";

 case HT_NXT_COMPASS_COMPASS:
  return "COMPASS";

 case HT_NXT_MAG_MAG:
  return "MAG";

 case HT_NXT_IR_SEEK_V2_DC:
  return "DC";
 case HT_NXT_IR_SEEK_V2_AC:
  return "AC";
 case HT_NXT_IR_SEEK_V2_DC_ALL:
  return "DC-ALL";
 case HT_NXT_IR_SEEK_V2_AC_ALL:
  return "AC-ALL";

 case HT_NXT_SMUX_MUX:
  return "MUX";

 case HT_SUPER_PRO_AIN:
  return "AIN";
 case HT_SUPER_PRO_DIN:
  return "DIN";
 case HT_SUPER_PRO_DOUT:
  return "DOUT";
 case HT_SUPER_PRO_DCTRL:
  return "DCTRL";
 case HT_SUPER_PRO_STROBE:
  return "STROBE";
 case HT_SUPER_PRO_LED:
  return "LED";
 case HT_SUPER_PRO_AOUT_0:
  return "AOUT-0";
 case HT_SUPER_PRO_AOUT_1:
  return "AOUT-1";

 case LEGO_EV3_US_US_DIST_CM:
  return "US-DIST-CM";
 case LEGO_EV3_US_US_DIST_IN:
  return "US-DIST-IN";
 case LEGO_EV3_US_US_LISTEN:
  return "US-LISTEN";
 case LEGO_EV3_US_US_SI_CM:
  return "US-SI-CM";
 case LEGO_EV3_US_US_SI_IN:
  return "US-SI-IN";
 case LEGO_EV3_US_US_DC_CM:
  return "US-DC-CM";
 case LEGO_EV3_US_US_DC_IN:
  return "US-DC-IN";

 case LEGO_EV3_GYRO_GYRO_ANG:
  return "GYRO-ANG";
 case LEGO_EV3_GYRO_GYRO_RATE:
  return "GYRO-RATE";
 case LEGO_EV3_GYRO_GYRO_FAS:
  return "GYRO-FAS";
 case LEGO_EV3_GYRO_GYRO_G_AND_A:
  return "GYRO-G&A";
 case LEGO_EV3_GYRO_GYRO_CAL:
  return "GYRO-CAL";

 case LEGO_EV3_COLOR_COL_REFLECT:
  return "COL-REFLECT";
 case LEGO_EV3_COLOR_COL_AMBIENT:
  return "COL-AMBIENT";
 case LEGO_EV3_COLOR_COL_COLOR:
  return "COL-COLOR";
 case LEGO_EV3_COLOR_REF_RAW:
  return "REF-RAW";
 case LEGO_EV3_COLOR_RGB_RAW:
  return "RGB-RAW";
 case LEGO_EV3_COLOR_COL_CAL:
  return "COL-CAL";

 case LEGO_EV3_TOUCH_TOUCH:
  return "TOUCH";

 case LEGO_EV3_IR_IR_PROX:
  return "IR-PROX";
 case LEGO_EV3_IR_IR_SEEK:
  return "IR-SEEK";
 case LEGO_EV3_IR_IR_REMOTE:
  return "IR-REMOTE";
 case LEGO_EV3_IR_IR_REM_A:
  return "IR-REM-A";
 case LEGO_EV3_IR_IR_S_ALT:
  return "IR-S-ALT";
 case LEGO_EV3_IR_IR_CAL:
  return "IR-CAL";

 case WEDO_HUB_HUB:
  return "HUB";

 case WEDO_MOTION_PROX:
  return "PROX";
 case WEDO_MOTION_RAW:
  return "RAW";

 case WEDO_TILT_TILT:
  return "TILT";
 case WEDO_TILT_TILT_AXIS:
  return "TILT-AXIS";
 case WEDO_TILT_RAW:
  return "RAW";

 case LEGO_POWER_STORAGE_IN_VOLT:
  return "IN-VOLT";
 case LEGO_POWER_STORAGE_IN_AMP:
  return "IN-AMP";
 case LEGO_POWER_STORAGE_OUT_VOLT:
  return "OUT-VOLT";
 case LEGO_POWER_STORAGE_OUT_AMP:
  return "OUT-AMP";
 case LEGO_POWER_STORAGE_JOULE:
  return "JOULE";
 case LEGO_POWER_STORAGE_IN_WATT:
  return "IN-WATT";
 case LEGO_POWER_STORAGE_OUT_WATT:
  return "OUT-WATT";
 case LEGO_POWER_STORAGE_ALL:
  return "ALL";

 case LEGO_NXT_TEMP_NXT_TEMP_C:
  return "NXT-TEMP-C";
 case LEGO_NXT_TEMP_NXT_TEMP_F:
  return "NXT-TEMP-F";

 case LEGO_NXT_TOUCH_TOUCH:
  return "TOUCH";

 case LEGO_NXT_LIGHT_REFLECT:
  return "REFLECT";
 case LEGO_NXT_LIGHT_AMBIENT:
  return "AMBIENT";

 case LEGO_NXT_SOUND_DB:
  return "DB";
 case LEGO_NXT_SOUND_DBA:
  return "DBA";

 case LEGO_NXT_US_US_DIST_CM:
  return "US-DIST-CM";
 case LEGO_NXT_US_US_DIST_IN:
  return "US-DIST-IN";
 case LEGO_NXT_US_US_SI_CM:
  return "US-SI-CM";
 case LEGO_NXT_US_US_SI_IN:
  return "US-SI-IN";
 case LEGO_NXT_US_US_LISTEN:
  return "US-LISTEN";

 case MI_XG1300L_ANGLE:
  return "ANGLE";
 case MI_XG1300L_SPEED:
  return "SPEED";
 case MI_XG1300L_ACCEL:
  return "ACCEL";
 case MI_XG1300L_ALL:
  return "ALL";

 case MS_ABSOLUTE_IMU_TILT:
  return "TILT";
 case MS_ABSOLUTE_IMU_ACCEL:
  return "ACCEL";
 case MS_ABSOLUTE_IMU_COMPASS:
  return "COMPASS";
 case MS_ABSOLUTE_IMU_MAG:
  return "MAG";
 case MS_ABSOLUTE_IMU_GYRO:
  return "GYRO";
 case MS_ABSOLUTE_IMU_ALL:
  return "ALL";

 case MS_ANGLE_ANGLE:
  return "ANGLE";
 case MS_ANGLE_ANGLE2:
  return "ANGLE2";
 case MS_ANGLE_SPEED:
  return "SPEED";
 case MS_ANGLE_ALL:
  return "ALL";

 case MS_EV3_SMUX_MUX:
  return "MUX";

 case MS_LIGHT_ARRAY_CAL:
  return "CAL";
 case MS_LIGHT_ARRAY_RAW:
  return "RAW";

 case MS_LINE_LEADER_PID:
  return "PID";
 case MS_LINE_LEADER_PID_ALL:
  return "PID-ALL";
 case MS_LINE_LEADER_CAL:
  return "CAL";
 case MS_LINE_LEADER_RAW:
  return "RAW";

 case MS_NXTCAM_TRACK:
  return "TRACK";

 case MS_NXTCAM5_TRACK:
  return "TRACK";

 case MS_NXTMMX_STATUS:
  return "STATUS";
 case MS_NXTMMX_STATUS_OLD:
  return "STATUS-OLD";

 case MS_8CH_SERVO_V3:
  return "V3";
 case MS_8CH_SERVO_OLD:
  return "OLD";

 case MS_PPS58_NX_RAW:
  return "RAW";
 case MS_PPS58_NX_ABS_PSI:
  return "ABS-PSI";
 case MS_PPS58_NX_ABS_MBAR:
  return "ABS-MBAR";
 case MS_PPS58_NX_ABS_KPA:
  return "ABS-KPA";
 case MS_PPS58_NX_REL_PSI:
  return "REL-PSI";
 case MS_PPS58_NX_REL_MBAR:
  return "REL-MBAR";
 case MS_PPS58_NX_REL_KPA:
  return "REL-KPA";

 case MS_PIXY_ADAPTER_TRACK:
  return "TRACK";

 case MS_NXT_TOUCH_MUX_TOUCH_MUX:
  return "TOUCH-MUX";

 }
 return ( "<unknown>" );
}

INX_T get_sensor_mode_inx_of_type( uint8_t sn, INX_T type_inx )
{
 char buf[ 64 ];

 if ( !get_sensor_mode( sn, buf, sizeof( buf ))) return ( SENSOR_MODE__NONE_ );

 switch ( type_inx ) {

 case EV3_ANALOG_XX:
  if ( strcmp( buf, "ANALOG" ) == 0 ) return EV3_ANALOG_XX_ANALOG;

  break;

 case NXT_ANALOG:
  if ( strcmp( buf, "ANALOG-0" ) == 0 ) return NXT_ANALOG_ANALOG_0;
  if ( strcmp( buf, "ANALOG-1" ) == 0 ) return NXT_ANALOG_ANALOG_1;

  break;

 case PIXY_LEGO:
  if ( strcmp( buf, "ALL" ) == 0 ) return PIXY_LEGO_ALL;
  if ( strcmp( buf, "SIG1" ) == 0 ) return PIXY_LEGO_SIG1;
  if ( strcmp( buf, "SIG2" ) == 0 ) return PIXY_LEGO_SIG2;
  if ( strcmp( buf, "SIG3" ) == 0 ) return PIXY_LEGO_SIG3;
  if ( strcmp( buf, "SIG4" ) == 0 ) return PIXY_LEGO_SIG4;
  if ( strcmp( buf, "SIG5" ) == 0 ) return PIXY_LEGO_SIG5;
  if ( strcmp( buf, "SIG6" ) == 0 ) return PIXY_LEGO_SIG6;
  if ( strcmp( buf, "SIG7" ) == 0 ) return PIXY_LEGO_SIG7;

  break;

 case DI_DFLEX:
  if ( strcmp( buf, "FLEX" ) == 0 ) return DI_DFLEX_FLEX;

  break;

 case FCL_9DOF:
  if ( strcmp( buf, "GYRO" ) == 0 ) return FCL_9DOF_GYRO;
  if ( strcmp( buf, "ACC" ) == 0 ) return FCL_9DOF_ACC;
  if ( strcmp( buf, "MAGNET" ) == 0 ) return FCL_9DOF_MAGNET;

  break;

 case FCL_ADC:
  if ( strcmp( buf, "CH1-VOLTAGE" ) == 0 ) return FCL_ADC_CH1_VOLTAGE;
  if ( strcmp( buf, "CH2-VOLTAGE" ) == 0 ) return FCL_ADC_CH2_VOLTAGE;
  if ( strcmp( buf, "VOLTAGE" ) == 0 ) return FCL_ADC_VOLTAGE;

  break;

 case FCL_ALTITUDE:
  if ( strcmp( buf, "PRESSURE" ) == 0 ) return FCL_ALTITUDE_PRESSURE;
  if ( strcmp( buf, "ALTITUDE" ) == 0 ) return FCL_ALTITUDE_ALTITUDE;

  break;

 case FCL_GESTURE:
  if ( strcmp( buf, "GESTURE" ) == 0 ) return FCL_GESTURE_GESTURE;
  if ( strcmp( buf, "PROXIMITY" ) == 0 ) return FCL_GESTURE_PROXIMITY;
  if ( strcmp( buf, "RGB-RAW" ) == 0 ) return FCL_GESTURE_RGB_RAW;
  if ( strcmp( buf, "CLEAR" ) == 0 ) return FCL_GESTURE_CLEAR;

  break;

 case FCL_HUMIDITY:
  if ( strcmp( buf, "CENTIGRADE" ) == 0 ) return FCL_HUMIDITY_CENTIGRADE;
  if ( strcmp( buf, "FAHRENHEIT" ) == 0 ) return FCL_HUMIDITY_FAHRENHEIT;
  if ( strcmp( buf, "HUMIDITY" ) == 0 ) return FCL_HUMIDITY_HUMIDITY;

  break;

 case FCL_IR:
  if ( strcmp( buf, "IR DATA" ) == 0 ) return FCL_IR_IR_DATA;

  break;

 case FCL_LIGHT:
  if ( strcmp( buf, "ILLUMINANCE" ) == 0 ) return FCL_LIGHT_ILLUMINANCE;

  break;

 case HT_NXT_COLOR:
  if ( strcmp( buf, "COLOR" ) == 0 ) return HT_NXT_COLOR_COLOR;
  if ( strcmp( buf, "RED" ) == 0 ) return HT_NXT_COLOR_RED;
  if ( strcmp( buf, "GREEN" ) == 0 ) return HT_NXT_COLOR_GREEN;
  if ( strcmp( buf, "BLUE" ) == 0 ) return HT_NXT_COLOR_BLUE;
  if ( strcmp( buf, "RAW" ) == 0 ) return HT_NXT_COLOR_RAW;
  if ( strcmp( buf, "NORM" ) == 0 ) return HT_NXT_COLOR_NORM;
  if ( strcmp( buf, "ALL" ) == 0 ) return HT_NXT_COLOR_ALL;

  break;

 case HT_NXT_ANGLE:
  if ( strcmp( buf, "ANGLE" ) == 0 ) return HT_NXT_ANGLE_ANGLE;
  if ( strcmp( buf, "ANGLE-ACC" ) == 0 ) return HT_NXT_ANGLE_ANGLE_ACC;
  if ( strcmp( buf, "SPEED" ) == 0 ) return HT_NXT_ANGLE_SPEED;

  break;

 case HT_NXT_ACCEL:
  if ( strcmp( buf, "ACCEL" ) == 0 ) return HT_NXT_ACCEL_ACCEL;
  if ( strcmp( buf, "ALL" ) == 0 ) return HT_NXT_ACCEL_ALL;

  break;

 case HT_NXT_BAROMETRIC:
  if ( strcmp( buf, "PRESS" ) == 0 ) return HT_NXT_BAROMETRIC_PRESS;
  if ( strcmp( buf, "TEMP" ) == 0 ) return HT_NXT_BAROMETRIC_TEMP;

  break;

 case HT_NXT_COLOR_V2:
  if ( strcmp( buf, "COLOR" ) == 0 ) return HT_NXT_COLOR_V2_COLOR;
  if ( strcmp( buf, "RED" ) == 0 ) return HT_NXT_COLOR_V2_RED;
  if ( strcmp( buf, "GREEN" ) == 0 ) return HT_NXT_COLOR_V2_GREEN;
  if ( strcmp( buf, "BLUE" ) == 0 ) return HT_NXT_COLOR_V2_BLUE;
  if ( strcmp( buf, "WHITE" ) == 0 ) return HT_NXT_COLOR_V2_WHITE;
  if ( strcmp( buf, "NORM" ) == 0 ) return HT_NXT_COLOR_V2_NORM;
  if ( strcmp( buf, "ALL" ) == 0 ) return HT_NXT_COLOR_V2_ALL;
  if ( strcmp( buf, "PASSIVE" ) == 0 ) return HT_NXT_COLOR_V2_PASSIVE;
  if ( strcmp( buf, "RAW" ) == 0 ) return HT_NXT_COLOR_V2_RAW;

  break;

 case HT_NXT_EOPD:
  if ( strcmp( buf, "LONG" ) == 0 ) return HT_NXT_EOPD_LONG;
  if ( strcmp( buf, "SHORT" ) == 0 ) return HT_NXT_EOPD_SHORT;

  break;

 case HT_NXT_FORCE:
  if ( strcmp( buf, "FORCE" ) == 0 ) return HT_NXT_FORCE_FORCE;

  break;

 case HT_NXT_GYRO:
  if ( strcmp( buf, "GYRO" ) == 0 ) return HT_NXT_GYRO_GYRO;

  break;

 case HT_NXT_IR_LINK:
  if ( strcmp( buf, "IRLINK" ) == 0 ) return HT_NXT_IR_LINK_IRLINK;

  break;

 case HT_NXT_IR_RECEIVER:
  if ( strcmp( buf, "1-MOTOR" ) == 0 ) return HT_NXT_IR_RECEIVER_1_MOTOR;
  if ( strcmp( buf, "8-MOTOR" ) == 0 ) return HT_NXT_IR_RECEIVER_8_MOTOR;

  break;

 case HT_NXT_PIR:
  if ( strcmp( buf, "PROX" ) == 0 ) return HT_NXT_PIR_PROX;

  break;

 case HT_NXT_COMPASS:
  if ( strcmp( buf, "COMPASS" ) == 0 ) return HT_NXT_COMPASS_COMPASS;

  break;

 case HT_NXT_MAG:
  if ( strcmp( buf, "MAG" ) == 0 ) return HT_NXT_MAG_MAG;

  break;

 case HT_NXT_IR_SEEK_V2:
  if ( strcmp( buf, "DC" ) == 0 ) return HT_NXT_IR_SEEK_V2_DC;
  if ( strcmp( buf, "AC" ) == 0 ) return HT_NXT_IR_SEEK_V2_AC;
  if ( strcmp( buf, "DC-ALL" ) == 0 ) return HT_NXT_IR_SEEK_V2_DC_ALL;
  if ( strcmp( buf, "AC-ALL" ) == 0 ) return HT_NXT_IR_SEEK_V2_AC_ALL;

  break;

 case HT_NXT_SMUX:
  if ( strcmp( buf, "MUX" ) == 0 ) return HT_NXT_SMUX_MUX;

  break;

 case HT_SUPER_PRO:
  if ( strcmp( buf, "AIN" ) == 0 ) return HT_SUPER_PRO_AIN;
  if ( strcmp( buf, "DIN" ) == 0 ) return HT_SUPER_PRO_DIN;
  if ( strcmp( buf, "DOUT" ) == 0 ) return HT_SUPER_PRO_DOUT;
  if ( strcmp( buf, "DCTRL" ) == 0 ) return HT_SUPER_PRO_DCTRL;
  if ( strcmp( buf, "STROBE" ) == 0 ) return HT_SUPER_PRO_STROBE;
  if ( strcmp( buf, "LED" ) == 0 ) return HT_SUPER_PRO_LED;
  if ( strcmp( buf, "AOUT-0" ) == 0 ) return HT_SUPER_PRO_AOUT_0;
  if ( strcmp( buf, "AOUT-1" ) == 0 ) return HT_SUPER_PRO_AOUT_1;

  break;

 case LEGO_EV3_US:
  if ( strcmp( buf, "US-DIST-CM" ) == 0 ) return LEGO_EV3_US_US_DIST_CM;
  if ( strcmp( buf, "US-DIST-IN" ) == 0 ) return LEGO_EV3_US_US_DIST_IN;
  if ( strcmp( buf, "US-LISTEN" ) == 0 ) return LEGO_EV3_US_US_LISTEN;
  if ( strcmp( buf, "US-SI-CM" ) == 0 ) return LEGO_EV3_US_US_SI_CM;
  if ( strcmp( buf, "US-SI-IN" ) == 0 ) return LEGO_EV3_US_US_SI_IN;
  if ( strcmp( buf, "US-DC-CM" ) == 0 ) return LEGO_EV3_US_US_DC_CM;
  if ( strcmp( buf, "US-DC-IN" ) == 0 ) return LEGO_EV3_US_US_DC_IN;

  break;

 case LEGO_EV3_GYRO:
  if ( strcmp( buf, "GYRO-ANG" ) == 0 ) return LEGO_EV3_GYRO_GYRO_ANG;
  if ( strcmp( buf, "GYRO-RATE" ) == 0 ) return LEGO_EV3_GYRO_GYRO_RATE;
  if ( strcmp( buf, "GYRO-FAS" ) == 0 ) return LEGO_EV3_GYRO_GYRO_FAS;
  if ( strcmp( buf, "GYRO-G&A" ) == 0 ) return LEGO_EV3_GYRO_GYRO_G_AND_A;
  if ( strcmp( buf, "GYRO-CAL" ) == 0 ) return LEGO_EV3_GYRO_GYRO_CAL;

  break;

 case LEGO_EV3_COLOR:
  if ( strcmp( buf, "COL-REFLECT" ) == 0 ) return LEGO_EV3_COLOR_COL_REFLECT;
  if ( strcmp( buf, "COL-AMBIENT" ) == 0 ) return LEGO_EV3_COLOR_COL_AMBIENT;
  if ( strcmp( buf, "COL-COLOR" ) == 0 ) return LEGO_EV3_COLOR_COL_COLOR;
  if ( strcmp( buf, "REF-RAW" ) == 0 ) return LEGO_EV3_COLOR_REF_RAW;
  if ( strcmp( buf, "RGB-RAW" ) == 0 ) return LEGO_EV3_COLOR_RGB_RAW;
  if ( strcmp( buf, "COL-CAL" ) == 0 ) return LEGO_EV3_COLOR_COL_CAL;

  break;

 case LEGO_EV3_TOUCH:
  if ( strcmp( buf, "TOUCH" ) == 0 ) return LEGO_EV3_TOUCH_TOUCH;

  break;

 case LEGO_EV3_IR:
  if ( strcmp( buf, "IR-PROX" ) == 0 ) return LEGO_EV3_IR_IR_PROX;
  if ( strcmp( buf, "IR-SEEK" ) == 0 ) return LEGO_EV3_IR_IR_SEEK;
  if ( strcmp( buf, "IR-REMOTE" ) == 0 ) return LEGO_EV3_IR_IR_REMOTE;
  if ( strcmp( buf, "IR-REM-A" ) == 0 ) return LEGO_EV3_IR_IR_REM_A;
  if ( strcmp( buf, "IR-S-ALT" ) == 0 ) return LEGO_EV3_IR_IR_S_ALT;
  if ( strcmp( buf, "IR-CAL" ) == 0 ) return LEGO_EV3_IR_IR_CAL;

  break;

 case WEDO_HUB:
  if ( strcmp( buf, "HUB" ) == 0 ) return WEDO_HUB_HUB;

  break;

 case WEDO_MOTION:
  if ( strcmp( buf, "PROX" ) == 0 ) return WEDO_MOTION_PROX;
  if ( strcmp( buf, "RAW" ) == 0 ) return WEDO_MOTION_RAW;

  break;

 case WEDO_TILT:
  if ( strcmp( buf, "TILT" ) == 0 ) return WEDO_TILT_TILT;
  if ( strcmp( buf, "TILT-AXIS" ) == 0 ) return WEDO_TILT_TILT_AXIS;
  if ( strcmp( buf, "RAW" ) == 0 ) return WEDO_TILT_RAW;

  break;

 case LEGO_POWER_STORAGE:
  if ( strcmp( buf, "IN-VOLT" ) == 0 ) return LEGO_POWER_STORAGE_IN_VOLT;
  if ( strcmp( buf, "IN-AMP" ) == 0 ) return LEGO_POWER_STORAGE_IN_AMP;
  if ( strcmp( buf, "OUT-VOLT" ) == 0 ) return LEGO_POWER_STORAGE_OUT_VOLT;
  if ( strcmp( buf, "OUT-AMP" ) == 0 ) return LEGO_POWER_STORAGE_OUT_AMP;
  if ( strcmp( buf, "JOULE" ) == 0 ) return LEGO_POWER_STORAGE_JOULE;
  if ( strcmp( buf, "IN-WATT" ) == 0 ) return LEGO_POWER_STORAGE_IN_WATT;
  if ( strcmp( buf, "OUT-WATT" ) == 0 ) return LEGO_POWER_STORAGE_OUT_WATT;
  if ( strcmp( buf, "ALL" ) == 0 ) return LEGO_POWER_STORAGE_ALL;

  break;

 case LEGO_NXT_TEMP:
  if ( strcmp( buf, "NXT-TEMP-C" ) == 0 ) return LEGO_NXT_TEMP_NXT_TEMP_C;
  if ( strcmp( buf, "NXT-TEMP-F" ) == 0 ) return LEGO_NXT_TEMP_NXT_TEMP_F;

  break;

 case LEGO_NXT_TOUCH:
  if ( strcmp( buf, "TOUCH" ) == 0 ) return LEGO_NXT_TOUCH_TOUCH;

  break;

 case LEGO_NXT_LIGHT:
  if ( strcmp( buf, "REFLECT" ) == 0 ) return LEGO_NXT_LIGHT_REFLECT;
  if ( strcmp( buf, "AMBIENT" ) == 0 ) return LEGO_NXT_LIGHT_AMBIENT;

  break;

 case LEGO_NXT_SOUND:
  if ( strcmp( buf, "DB" ) == 0 ) return LEGO_NXT_SOUND_DB;
  if ( strcmp( buf, "DBA" ) == 0 ) return LEGO_NXT_SOUND_DBA;

  break;

 case LEGO_NXT_US:
  if ( strcmp( buf, "US-DIST-CM" ) == 0 ) return LEGO_NXT_US_US_DIST_CM;
  if ( strcmp( buf, "US-DIST-IN" ) == 0 ) return LEGO_NXT_US_US_DIST_IN;
  if ( strcmp( buf, "US-SI-CM" ) == 0 ) return LEGO_NXT_US_US_SI_CM;
  if ( strcmp( buf, "US-SI-IN" ) == 0 ) return LEGO_NXT_US_US_SI_IN;
  if ( strcmp( buf, "US-LISTEN" ) == 0 ) return LEGO_NXT_US_US_LISTEN;

  break;

 case MI_XG1300L:
  if ( strcmp( buf, "ANGLE" ) == 0 ) return MI_XG1300L_ANGLE;
  if ( strcmp( buf, "SPEED" ) == 0 ) return MI_XG1300L_SPEED;
  if ( strcmp( buf, "ACCEL" ) == 0 ) return MI_XG1300L_ACCEL;
  if ( strcmp( buf, "ALL" ) == 0 ) return MI_XG1300L_ALL;

  break;

 case MS_ABSOLUTE_IMU:
  if ( strcmp( buf, "TILT" ) == 0 ) return MS_ABSOLUTE_IMU_TILT;
  if ( strcmp( buf, "ACCEL" ) == 0 ) return MS_ABSOLUTE_IMU_ACCEL;
  if ( strcmp( buf, "COMPASS" ) == 0 ) return MS_ABSOLUTE_IMU_COMPASS;
  if ( strcmp( buf, "MAG" ) == 0 ) return MS_ABSOLUTE_IMU_MAG;
  if ( strcmp( buf, "GYRO" ) == 0 ) return MS_ABSOLUTE_IMU_GYRO;
  if ( strcmp( buf, "ALL" ) == 0 ) return MS_ABSOLUTE_IMU_ALL;

  break;

 case MS_ANGLE:
  if ( strcmp( buf, "ANGLE" ) == 0 ) return MS_ANGLE_ANGLE;
  if ( strcmp( buf, "ANGLE2" ) == 0 ) return MS_ANGLE_ANGLE2;
  if ( strcmp( buf, "SPEED" ) == 0 ) return MS_ANGLE_SPEED;
  if ( strcmp( buf, "ALL" ) == 0 ) return MS_ANGLE_ALL;

  break;

 case MS_EV3_SMUX:
  if ( strcmp( buf, "MUX" ) == 0 ) return MS_EV3_SMUX_MUX;

  break;

 case MS_LIGHT_ARRAY:
  if ( strcmp( buf, "CAL" ) == 0 ) return MS_LIGHT_ARRAY_CAL;
  if ( strcmp( buf, "RAW" ) == 0 ) return MS_LIGHT_ARRAY_RAW;

  break;

 case MS_LINE_LEADER:
  if ( strcmp( buf, "PID" ) == 0 ) return MS_LINE_LEADER_PID;
  if ( strcmp( buf, "PID-ALL" ) == 0 ) return MS_LINE_LEADER_PID_ALL;
  if ( strcmp( buf, "CAL" ) == 0 ) return MS_LINE_LEADER_CAL;
  if ( strcmp( buf, "RAW" ) == 0 ) return MS_LINE_LEADER_RAW;

  break;

 case MS_NXTCAM:
  if ( strcmp( buf, "TRACK" ) == 0 ) return MS_NXTCAM_TRACK;

  break;

 case MS_NXTCAM5:
  if ( strcmp( buf, "TRACK" ) == 0 ) return MS_NXTCAM5_TRACK;

  break;

 case MS_NXTMMX:
  if ( strcmp( buf, "STATUS" ) == 0 ) return MS_NXTMMX_STATUS;
  if ( strcmp( buf, "STATUS-OLD" ) == 0 ) return MS_NXTMMX_STATUS_OLD;

  break;

 case MS_8CH_SERVO:
  if ( strcmp( buf, "V3" ) == 0 ) return MS_8CH_SERVO_V3;
  if ( strcmp( buf, "OLD" ) == 0 ) return MS_8CH_SERVO_OLD;

  break;

 case MS_PPS58_NX:
  if ( strcmp( buf, "RAW" ) == 0 ) return MS_PPS58_NX_RAW;
  if ( strcmp( buf, "ABS-PSI" ) == 0 ) return MS_PPS58_NX_ABS_PSI;
  if ( strcmp( buf, "ABS-MBAR" ) == 0 ) return MS_PPS58_NX_ABS_MBAR;
  if ( strcmp( buf, "ABS-KPA" ) == 0 ) return MS_PPS58_NX_ABS_KPA;
  if ( strcmp( buf, "REL-PSI" ) == 0 ) return MS_PPS58_NX_REL_PSI;
  if ( strcmp( buf, "REL-MBAR" ) == 0 ) return MS_PPS58_NX_REL_MBAR;
  if ( strcmp( buf, "REL-KPA" ) == 0 ) return MS_PPS58_NX_REL_KPA;

  break;

 case MS_PIXY_ADAPTER:
  if ( strcmp( buf, "TRACK" ) == 0 ) return MS_PIXY_ADAPTER_TRACK;

  break;

 case MS_NXT_TOUCH_MUX:
  if ( strcmp( buf, "TOUCH-MUX" ) == 0 ) return MS_NXT_TOUCH_MUX_TOUCH_MUX;

  break;

 }
 return ( SENSOR_MODE__UNKNOWN_ );
}

INX_T get_sensor_mode_inx( uint8_t sn )
{
 return get_sensor_mode_inx_of_type( sn, ev3_sensor_desc( sn )->type_inx );
}

size_t set_sensor_mode_inx( uint8_t sn, INX_T mode_inx )
{
 return set_sensor_mode( sn, ( char *) ev3_sensor_mode( mode_inx ));
}

size_t multi_set_sensor_mode_inx( uint8_t *sn, INX_T mode_inx )
{
 return multi_set_sensor_mode( sn, ( char *) ev3_sensor_mode( mode_inx ));
}

const char *ev3_sensor_command( INX_T command_inx )
{
 switch ( command_inx ) {

 case HT_NXT_ANGLE_RESET:
  return "RESET";
 case HT_NXT_ANGLE_CAL:
  return "CAL";

 case HT_NXT_SMUX_HALT:
  return "HALT";
 case HT_NXT_SMUX_DETECT:
  return "DETECT";
 case HT_NXT_SMUX_RUN:
  return "RUN";

 case WEDO_HUB_OUT_OFF:
  return "OUT-OFF";
 case WEDO_HUB_OUT_ON:
  return "OUT-ON";
 case WEDO_HUB_CLEAR_ERR:
  return "CLEAR-ERR";

 case MI_XG1300L_RESET:
  return "RESET";
 case MI_XG1300L_ACCEL_2G:
  return "ACCEL-2G";
 case MI_XG1300L_ACCEL_4G:
  return "ACCEL-4G";
 case MI_XG1300L_ACCEL_8G:
  return "ACCEL-8G";

 case MS_ABSOLUTE_IMU_BEGIN_COMP_CAL:
  return "BEGIN-COMP-CAL";
 case MS_ABSOLUTE_IMU_END_COMP_CAL:
  return "END-COMP-CAL";
 case MS_ABSOLUTE_IMU_ACCEL_2G:
  return "ACCEL-2G";
 case MS_ABSOLUTE_IMU_ACCEL_4G:
  return "ACCEL-4G";
 case MS_ABSOLUTE_IMU_ACCEL_8G:
  return "ACCEL-8G";
 case MS_ABSOLUTE_IMU_ACCEL_16G:
  return "ACCEL-16G";

 case MS_ANGLE_RESET:
  return "RESET";

 case MS_LIGHT_ARRAY_CAL_WHITE:
  return "CAL-WHITE";
 case MS_LIGHT_ARRAY_CAL_BLACK:
  return "CAL-BLACK";
 case MS_LIGHT_ARRAY_SLEEP:
  return "SLEEP";
 case MS_LIGHT_ARRAY_WAKE:
  return "WAKE";
 case MS_LIGHT_ARRAY_60HZ:
  return "60HZ";
 case MS_LIGHT_ARRAY_50HZ:
  return "50HZ";
 case MS_LIGHT_ARRAY_UNIVERSAL:
  return "UNIVERSAL";

 case MS_LINE_LEADER_CAL_WHITE:
  return "CAL-WHITE";
 case MS_LINE_LEADER_CAL_BLACK:
  return "CAL-BLACK";
 case MS_LINE_LEADER_SLEEP:
  return "SLEEP";
 case MS_LINE_LEADER_WAKE:
  return "WAKE";
 case MS_LINE_LEADER_INV_COL:
  return "INV-COL";
 case MS_LINE_LEADER_RST_COL:
  return "RST-COL";
 case MS_LINE_LEADER_SNAP:
  return "SNAP";
 case MS_LINE_LEADER_60HZ:
  return "60HZ";
 case MS_LINE_LEADER_50HZ:
  return "50HZ";
 case MS_LINE_LEADER_UNIVERSAL:
  return "UNIVERSAL";

 case MS_NXTCAM_TRACK_ON:
  return "TRACK-ON";
 case MS_NXTCAM_TRACK_OFF:
  return "TRACK-OFF";
 case MS_NXTCAM_TRACK_OBJ:
  return "TRACK-OBJ";
 case MS_NXTCAM_TRACK_LINE:
  return "TRACK-LINE";
 case MS_NXTCAM_SORT_SIZE:
  return "SORT-SIZE";
 case MS_NXTCAM_SORT_COL:
  return "SORT-COL";

 case MS_NXTCAM5_TRACK_OBJ:
  return "TRACK-OBJ";
 case MS_NXTCAM5_TRACK_FACE:
  return "TRACK-FACE";
 case MS_NXTCAM5_MULTI_MOVIE:
  return "MULTI-MOVIE";
 case MS_NXTCAM5_MOVIE:
  return "MOVIE";
 case MS_NXTCAM5_PICTURE:
  return "PICTURE";
 case MS_NXTCAM5_TRACK_EYE:
  return "TRACK-EYE";
 case MS_NXTCAM5_TRACK_QR:
  return "TRACK-QR";
 case MS_NXTCAM5_TRACK_LINE:
  return "TRACK-LINE";

 case MS_PPS58_NX_ZERO:
  return "ZERO";

 case MS_PIXY_ADAPTER_SORT_SIZE:
  return "SORT-SIZE";
 case MS_PIXY_ADAPTER_SORT_COL:
  return "SORT-COL";

 }
 return ( "<unknown>" );
}

size_t set_sensor_command_inx( uint8_t sn, INX_T command_inx )
{
 return set_sensor_command( sn, ( char *) ev3_sensor_command( command_inx ));
}

size_t multi_set_sensor_command_inx( uint8_t *sn, INX_T command_inx )
{
 return multi_set_sensor_command( sn, ( char *) ev3_sensor_command( command_inx ));
}

int ev3_sensor_init( void )
{
 char list[ 256 ];
 char *p;
 uint32_t sn;
 int cnt = 0;

 memset( ev3_sensor, 0, sizeof( ev3_sensor ));

 if ( !ev3_listdir( "/sys/class/lego-sensor", list, sizeof( list ))) return ( -1 );

 p = strtok( list, " " );
 while ( p ) {
  if (( ev3_string_suffix( "sensor", &p, &sn ) == 1 ) && ( sn < 64)) {
   get_sensor_desc( sn, ev3_sensor + sn );
   ++cnt;
  }
  p = strtok( ((void *)0), " " );
 }
 return ( cnt );
}
